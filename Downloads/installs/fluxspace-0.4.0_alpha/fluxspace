#!/usr/bin/env python
######################################################################
######################################################################
# Fluxspace - main program
#
# Converted during build from "main.py" to the executable "main".
# The local python path is inserted in order to make it self-running
# and have the proper process name.
######################################################################
######################################################################

import os
import os.path
import sys
import getopt
import string
import time
import shutil
import signal

# Script found in path to debug the pid of fluxspace..
# The pid is the only argument to the script.
debugScript = 'test/fluxspace-debug-pid'

# Need to seed the library path with the lib subdirectory in order to import
# the process module, which does the rest of the path setup.
sys.path.insert(0, os.path.join(os.path.split(os.path.realpath(sys.argv[0]))[0], 'lib'))

# Constants used to handle race condition between starting fluxlets and starting
# the display SOAP object.  It also enforces better sequencing for assigning
# display real estate.  This should be handled better in future releases.
fluxfeedDelay          = 2.0        # Delay before starting fluxfeed (incremented)
fluxfeedDelayIncrement = 2.0        # Amount to increase fluxfeed start delay

######################################################################
def FluxspaceImportError(module, msg):
######################################################################
    print '''
ERROR: Failed to import Fluxspace module "%s"

Python error:
    %s
''' % (module, msg)

    (subdir, fileroot) = os.path.split(module.replace('.', os.path.sep))
    file1 = os.path.join(fluxspace.process.myDir, 'lib', subdir, '%s.py' % module)
    file2 = os.path.join(fluxspace.process.myDir, 'lib', subdir, 'lib%s.so' % module)
    if os.path.isfile(file1):
        print '''\
"%s" seems to exist.  It may either be a bad copy or a missing module dependency.
Check the output above for other errors and warnings.
''' % file1
    elif os.path.isfile(file2):
        print '''\
"%s" seems to exist.  It may either be a bad copy or symlink or a missing module
dependency.  Check the output above for other errors and warnings.
''' % file2
    else:
        print '''\
Neither of the two possible module files exists on your system.

    %s
    %s

Please verify that the install succeeded and that the installing user has
appropriate permissions at that location.

Problems may occur with binary modules (ending in ".so") when Fluxspace and
Python are built with a different and incompatible versions of the GCC/G++
compiler.  Please consider trying one or more of the following steps.

- Install a more recent compiler version, if available.  Rebuild and reinstall
  Fluxspace.

- Download and install the most recent stable Python version from
  http://www.python.org.  Note that some distributions, Red Hat in particular,
  require a specific version of Python for their own tools.  Hence the new
  Python must get installed in parallel.  The Red Hat packages available at
  Python.org will do this automatically.

- Rebuild and reinstall Fluxspace after forcing the use of a different compiler
  version.  E.g. the following commands build with GCC 2.96 and then reinstall.

    $ make clean
    $ CC=gcc296 CXX=g++296 ./configure
    $ make
    $ make install

- Reinstall Python from a source package that you rebuild using the currently-
  installed compiler.
''' % (file1, file2)
    sys.exit(1)

######################################################################
# Watch carefully for possible installation problems preventing import.
######################################################################
try:
    import fluxspacecore
except ImportError, e:
    FluxspaceImportError('fluxspacecore', e)
try:
    import fluxspace.config
except ImportError, e:
    FluxspaceImportError('fluxspace.config', e)
try:
    import fluxspace.process
except ImportError, e:
    FluxspaceImportError('fluxspace.process', e)
try:
    import fluxspace.version
except ImportError, e:
    FluxspaceImportError('fluxspace.version', e)

######################################################################
# Spawn a debugger on this process by invoking an external
# script named fluxspace-debug-pid
def SpawnDebugger():
######################################################################
    if not os.path.isfile(debugScript):
        Abort(1, 'ERROR: Debug script "%s" does not exist' % debugScript)
    print 'Spawning debugger...'
    if os.fork() == 0:
        os.execlp(debugScript, debugScript, str(fluxspace.process.pid))
    else:
        time.sleep(2)

######################################################################
def Abort(retcode = 0, message = None):
######################################################################
    if message is not None and message != '':
        print 'fluxspace: %s' % message
    elif retcode != 0:
        print 'Unknown exception caught'
    if retcode != 0:
        print '<abort>'
    sys.exit(retcode)

######################################################################
def Usage(retcode = 0, message = None):
######################################################################
    if message is not None and message != '':
        print message
    print '''
Usage: fluxspace [OPTIONS] [ACTION]

   OPTIONS
      -c,--config CONFIG    Specify config file name (default=%s)
      -d,--display DISPLAY  Specify X display (override DISPLAY variable)
      -h,--help             Display this help message
      -v,--verbose          Display verbose trace messages
      -V,--version          Display version number
      --debug               Run the debugger on this process [1]

    ACTION
      start          Start Fluxpace, if not already running.
      restart        Stop Fluxspace, if running, and then start it (again). [2]
      stop           Stop Fluxspace and its child processes.
      feed NAME ...  Start the specified Fluxfeed(s) in the background.
                     Fluxspace must already be running.

   Notes:
      [1] The --debug option only works in the Fluxspace source directory.
      [2] Running with no command performs a restart.
''' % (fluxspace.config.defaultConfigFileName)
    Abort(retcode)

actions = ('start', 'restart', 'stop', 'feed')

######################################################################
def PrepareConfiguration():
######################################################################
    # Handle configuration migration from an older Fluxspace version.
    # The configuration is the same XML format, but it now needs to be
    # ~/.fluxspace/fluxspace.conf rather than ~/.fluxbox/fluxspace.conf or
    # ~/.fluxspace/fluxspace.xml.
    # Let's be nice and (as needed) create the directory, move the old configuration,
    # and or create a new configuration based on the example.
    fluxspaceConf = os.path.join(fluxspace.process.userFluxspaceDir, 'fluxspace.conf')
    fluxspaceOld1 = os.path.join(fluxspace.process.userFluxspaceDir, 'fluxspace.xml')
    fluxspaceOld2 = os.path.join(fluxspace.process.userFluxboxDir,   'fluxspace.xml')
    for dir in (fluxspace.process.userFluxspaceDir,
                fluxspace.process.userLibDir,
                fluxspace.process.userCacheDir,
                fluxspace.process.userFluxfeedDir,
                fluxspace.process.userFluxletDir):
        if not os.path.exists(dir):
            print '*** Creating directory "%s" ***' % dir
            os.mkdir(dir)
    if not os.path.exists(fluxspaceConf):
        old = None
        if os.path.exists(fluxspaceOld1):
            old = fluxspaceOld1
        elif os.path.exists(fluxspaceOld2):
            old = fluxspaceOld2
        if old is not None:
            print '*** Backing up old configuration "%s" ***' % old
            shutil.copy(old, '%s.old' % old)
            print '*** Moving old configuration to "%s" ***' % fluxspaceConf
            shutil.move(old, fluxspaceConf)
            f = open('%s.README' % old, 'w')
            f.write('*** The Fluxspace configuration file has been moved to %s ***\n' % fluxspaceConf)
            f.close()
        else:
            print '*** Creating new configuration "%s" ***' % fluxspaceConf
            exampleConf = os.path.join(fluxspace.process.myDir, 'examples', 'fluxspace.conf')
            shutil.copy(exampleConf, fluxspace.process.userFluxspaceDir)

######################################################################
class Controller(fluxspacecore.Controller):
######################################################################
    def BadElement(self, severity, message, element):
        lineInfo = ''
        if element.line > 0:
            lineInfo = 'line %d - ' % element.line
        fmt = 'Configuration error - %sElement "%s": %s'
        self.Message(severity, fmt % (lineInfo, element.name, message))

######################################################################
class FluxspaceSOAPHandler:
######################################################################
    def __init__(self, runningInstance):
        self.runningInstance = runningInstance
    def SOAPPoll(self):
        self.runningInstance.SOAPPoll()
    def RegisterSOAPObject(self, object, namespace):
        ns = 'urn:fluxspace.%s' % namespace
        self.runningInstance.RegisterSOAPObject(object, ns)

######################################################################
def FluxfeedPath(feedName):
######################################################################
    for fluxfeedDir in fluxspace.process.fluxfeedDirs:
        feedPath = os.path.join(fluxfeedDir, feedName)
        if os.path.isfile(feedPath) and (os.stat(feedPath).st_mode & 0100) != 0:
            return feedPath
    return None

######################################################################
def IsFluxfeed(feedName):
######################################################################
    return (FluxfeedPath(feedName) is not None)

######################################################################
def StartFluxfeed(feedName):
######################################################################
    global fluxfeedDelay, fluxfeedDelayIncrement
    pid = 0
    feedPath = FluxfeedPath(feedName)
    if feedPath is not None:
        print '\nStarting Fluxfeed "%s"...' % feedName
        pid = os.fork()
        if pid == 0:
            # Delay enough to let previous feed establish its real estate and
            # to allow the SOAP server fluxlet to start.
            time.sleep(fluxfeedDelay)
            os.execv(feedPath, [feedPath])
        fluxfeedDelay += fluxfeedDelayIncrement
    if pid == 0:
        print '''
* Unable to start Fluxfeed "%s" *

Make sure one of the following exists and is executable:
''' % feedName
    for dir in fluxspace.process.fluxfeedDirs:
        print '    %s' % os.path.join(dir, feedName)
    print ''
    return pid

######################################################################
if __name__ == '__main__':
######################################################################

    verbose = False
    debug   = False

    try:
        display = os.environ["DISPLAY"]
        opts, args = getopt.getopt(sys.argv[1:], 'c:d:hvV', ['config=', 'debug', 'display=', 'help', 'verbose', 'version'])
    except getopt.error, message:
        Usage(1, message)
    except KeyError, e:
        Abort(2, 'Environment variable "%s" not set' % e)
    except:
        Usage(3)

    for opt in opts:
        if opt[0] == '-c' or opt[0] == '--config':
            configFileName = opt[1]
        elif opt[0] == '-d' or opt[0] == '--display':
            display = opt[1]
        elif opt[0] == '-h' or opt[0] == '--help':
            Usage()
        elif opt[0] == '-v' or opt[0] == '--verbose':
            verbose = True
        elif opt[0] == '--debug':
            debug = True
            verbose = True
        elif opt[0] == '-V' or opt[0] == '--version':
            print 'Fluxspace version %s' % fluxspace.version.version
            sys.exit()

    # Default to the "restart" action.
    action = 'restart'
    if len(args) > 0:
        if args[0].lower() not in actions:
            Usage(3, 'Bad action specified, "%s"' % string.join(args))
        action = args[0].lower()

    # Make sure the .fluxspace directory is reasonably set up.
    # Migrate old configuration or create a new one.
    PrepareConfiguration()

    # Stop running fluxspace?
    otherInstance = fluxspace.process.FluxspaceProxy(display)
    if action in ('restart', 'stop'):
        stopped = False
        if otherInstance.IsAlive():
            stopped = otherInstance.Kill()
        if action == 'stop' and not stopped:
            print 'Fluxspace is not running'

    # Start one or more fluxfeeds?
    elif action == 'feed':
        for name in args[1:]:
            StartFluxfeed(name)
        sys.exit(0)

    if debug:
        SpawnDebugger()

    # Run?
    if action not in ('start', 'restart'):
        sys.exit(0)

    # Load the configuration file.
    # Need the controller in order to trace the configuration file load.
    controller = Controller(display, verbose)
    fluxspace.config.SetTracer(controller)
    config = fluxspace.config.Config()
    try:
        config.Load()
    except fluxspace.config.ConfigException, e:
        Abort(1, e.message)

    # Make sure the general purpose display SOAP server fluxlet is registered
    controller.Trace('Adding module "display"...')
    controller.RegisterFluxlet('fluxlet.display', None)
    controller.Trace('Module "display" added')

    # Load enabled fluxlets
    feeds = []
    for module in config.modules:
        fullName = 'fluxlet.' + module.name
        controller.Trace('Adding module "%s"...' % fullName)
        if controller.RegisterFluxlet(fullName, module.config):
            controller.Trace('Module "%s" added' % fullName)
        else:
            # If the fluxlet isn't found try to start a fluxfeed.
            if IsFluxfeed(module.name):
                feeds.append(module.name)
            else:
                controller.Message(1, 'Unable to load fluxlet or fluxfeed "%s"' % module.name)

    # Pass along specific configuration information
    width = config.root[0].getAttribute('width')
    if width:
        controller.SetWidth(int(width))
    frameWidth = config.root[0].getAttribute('framewidth')
    if frameWidth:
        controller.SetFrameWidth(int(frameWidth))
    rowGap = config.root[0].getAttribute('rowgap')
    if rowGap:
        controller.SetRowGap(int(rowGap))
    antialias = config.root[0].getAttribute('antialias')
    if antialias:
        controller.SetAntialias(antialias == 'yes')
    font = config.root[0].getAttribute('normalfont')
    if font:
        controller.SetNormalFont(font)
    font = config.root[0].getAttribute('smallfont')
    if font:
        controller.SetSmallFont(font)
    font = config.root[0].getAttribute('largefont')
    if font:
        controller.SetLargeFont(font)

    # Keep track of this running instance and create a SOAP server
    thisInstance = fluxspace.process.FluxspaceInstance(display)

    # Set up the SOAP server so that fluxlets can register objects
    soapHandler = FluxspaceSOAPHandler(thisInstance)
    controller.SetSOAPHandler(soapHandler)

    # Start fluxfeeds now since the SOAP server is ready.  Hopefully the SOAP
    # objects will by registered in time to service the first requests.
    # The increasing delay preceding each fluxfeed start serves two purposes.
    # It allows the previous feed to grab display real estate, so that the
    # display sequence mirrors the configuration sequence.
    # It also allows the display fluxlet time to register as a SOAP object.
    #TODO: This is a hack.  Make order explicit by assigning display blocks
    # and allowing random row insertion.  Also add some retry logic in process.py
    # so that it can wait for display.py to register.
    feedPIDs = []
    for feed in feeds:
        feedPIDs.append(StartFluxfeed(feed))

    # Event loop
    controller.Trace('Starting event loop...')
    try:
        controller.StartEvents()
    except fluxspacecore.ErrorAccessFluxbox:
        Abort(2, 'Unable to access Fluxbox configuration')
    except RuntimeError:
        Abort(2, 'Failed to start Fluxspace - see previous errors')

    print 'Stopping Fluxspace...'

    # Kill all the feeds we know about that are still running.
    for feedPID in feedPIDs:
        try:
            os.kill(feedPID, signal.SIGINT)
        except OSError:
            pass

    config.Close()
